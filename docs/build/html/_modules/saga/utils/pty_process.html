

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>saga.utils.pty_process &mdash; SAGA 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="top" title="SAGA 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="saga" href="../../saga.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SAGA 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../saga.html" accesskey="U">saga</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for saga.utils.pty_process</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pty</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">shlex</span>
<span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="kn">import</span> <span class="nn">saga.utils.logger</span>
<span class="kn">import</span> <span class="nn">saga.exceptions</span> <span class="kn">as</span> <span class="nn">se</span>


<span class="c"># --------------------------------------------------------------------</span>
<span class="c">#</span>
<span class="n">_CHUNKSIZE</span> <span class="o">=</span> <span class="mi">1024</span>   <span class="c"># default size of each read</span>
<span class="n">_POLLDELAY</span> <span class="o">=</span> <span class="mf">0.0001</span> <span class="c"># seconds in between read attempts</span>


<span class="c"># --------------------------------------------------------------------</span>
<span class="c">#</span>
<span class="k">class</span> <span class="nc">PTYProcess</span> <span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="p">:</span>
<div class="viewcode-block" id="PTYProcess"><a class="viewcode-back" href="../../../developers/adaptorwriting.html#saga.utils.pty_process.PTYProcess">[docs]</a>    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class spawns a process, providing that child with pty io channels --</span>
<span class="sd">    it will maintain stdin, stdout and stderr channels to the child.  All</span>
<span class="sd">    write* operations operate on the stdin, all read* operations operate on the</span>
<span class="sd">    stdout stream.  Data from the stderr stream are at this point redirected to</span>
<span class="sd">    the stdout channel.</span>

<span class="sd">    Example::</span>

<span class="sd">        pty = PTYProcess (&quot;/usr/bin/ssh -t localhost&quot;)</span>
<span class="sd">        pty.run ()</span>

<span class="sd">        n, match = pty.find ([&#39;password\s*:\s*$&#39;, </span>
<span class="sd">                              &#39;want to continue connecting.*\(yes/no\)\s*$&#39;, </span>
<span class="sd">                              &#39;[\$#&gt;]\s*$&#39;])</span>

<span class="sd">        while True :</span>

<span class="sd">            if n == 0 :</span>
<span class="sd">                # found password prompt</span>
<span class="sd">                pty.write (&quot;secret\\n&quot;)</span>
<span class="sd">                n, match = pty.find ([&#39;password\s*:\s*$&#39;, </span>
<span class="sd">                                      &#39;want to continue connecting.*\(yes/no\)\s*$&#39;, </span>
<span class="sd">                                      &#39;[\$#&gt;]\s*$&#39;])</span>
<span class="sd">            elif n == 1 :</span>
<span class="sd">                # found request to accept host key</span>
<span class="sd">                pty.write (&quot;yes\\n&quot;)</span>
<span class="sd">                n, match = pty.find ([&#39;password\s*:\s*$&#39;, </span>
<span class="sd">                                      &#39;want to continue connecting.*\(yes/no\)\s*$&#39;, </span>
<span class="sd">                                      &#39;[\$#&gt;]\s*$&#39;])</span>
<span class="sd">            elif n == 2 :</span>
<span class="sd">                # found some prompt</span>
<span class="sd">                break</span>
<span class="sd">        </span>
<span class="sd">        while pty.alive () :</span>
<span class="sd">            # send sleeps as quickly as possible, forever...</span>
<span class="sd">            pty.find ([&#39;[\$#&gt;]\s*$&#39;])</span>
<span class="sd">            pty.write (&quot;/bin/sleep 10\\n&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># ----------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The class constructor, which runs (execvpe) command in a separately</span>
<span class="sd">        forked process.  The bew process will inherit the environment of the</span>
<span class="sd">        application process.</span>

<span class="sd">        :type  command: string or list of strings</span>
<span class="sd">        :param command: The given command is what is run as a child, and</span>
<span class="sd">        fed/drained via pty pipes.  If given as string, command is split into an</span>
<span class="sd">        array of strings (simple splis on white space), as that is what</span>
<span class="sd">        :func:`subprocess.Popen` wants.</span>

<span class="sd">        :type  command: string or list of strings</span>
<span class="sd">        :param command: The given command is what is run as a child, and</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">split</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">BadParameter</span> <span class="p">(</span><span class="s">&quot;PTYProcess expects string or list command&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">BadParameter</span> <span class="p">(</span><span class="s">&quot;PTYProcess expects non-empty command&quot;</span><span class="p">)</span>


        <span class="k">try</span> <span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">command</span> <span class="c"># list of strings too run()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>   <span class="o">=</span> <span class="s">&quot;&quot;</span>      <span class="c"># data cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clog</span>    <span class="o">=</span> <span class="s">&quot;&quot;</span>      <span class="c"># log the data cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child</span>   <span class="o">=</span> <span class="bp">None</span>    <span class="c"># the process as created by subprocess.Popen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span>  <span class="o">=</span> <span class="n">logger</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">saga</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getLogger</span> <span class="p">(</span><span class="s">&#39;PTYProcess&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;PTYProcess: </span><span class="si">%s</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span> <span class="p">((</span><span class="n">command</span><span class="p">)))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">parent_in</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">child_in</span>  <span class="o">=</span> <span class="n">pty</span><span class="o">.</span><span class="n">openpty</span> <span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_out</span> <span class="o">=</span> <span class="n">pty</span><span class="o">.</span><span class="n">openpty</span> <span class="p">()</span>
         <span class="c">#  self.parent_err, self.child_err = pty.openpty ()</span>

            <span class="c"># create the child</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span> <span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not run (</span><span class="si">%s</span><span class="s">): </span><span class="si">%s</span><span class="s">&quot;</span> \
                                 <span class="o">%</span> <span class="p">(</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span> <span class="p">(</span><span class="n">command</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="p">:</span>
                <span class="k">try</span> <span class="p">:</span>
                    <span class="c"># this is the child</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_in</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">)</span>
                  <span class="c"># os.close (self.parent_err)</span>
                    
                  <span class="c"># # reopen stdio unbuffered</span>
                  <span class="c"># # </span>
                  <span class="c"># # this mechanism is actually useful, but, for some obscure</span>
                  <span class="c"># # (to me) reason fails badly if the applications stdio is</span>
                  <span class="c"># # redirected -- which is a very valid use case.  So, we</span>
                  <span class="c"># # keep I/O buffered, and need to get pipes flushed otherwise</span>
                  <span class="c"># # (newlines much?)</span>
                  <span class="c"># unbuf_in  = os.fdopen (sys.stdin.fileno(),  &#39;r+&#39;, 0)</span>
                  <span class="c"># unbuf_out = os.fdopen (sys.stdout.fileno(), &#39;w+&#39;, 0)</span>
                  <span class="c"># unbuf_err = os.fdopen (sys.stderr.fileno(), &#39;w+&#39;, 0)</span>
                  <span class="c">#</span>
                  <span class="c"># os.dup2 (self.child_in,  unbuf_in.fileno())</span>
                  <span class="c"># os.dup2 (self.child_out, unbuf_out.fileno())</span>
                  <span class="c"># os.dup2 (self.child_out, unbuf_err.fileno())</span>

                    <span class="c"># redirect stdio</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">dup2</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_in</span><span class="p">,</span>  <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">dup2</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_out</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">dup2</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_out</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>

                    <span class="n">os</span><span class="o">.</span><span class="n">execvpe</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">command</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span> <span class="p">(</span><span class="s">&quot;Could not execute (</span><span class="si">%s</span><span class="s">): </span><span class="si">%s</span><span class="s">&quot;</span> \
                                    <span class="o">%</span> <span class="p">(</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span> <span class="p">(</span><span class="n">command</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">else</span> <span class="p">:</span>
                <span class="c"># parent</span>
                <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_in</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_out</span><span class="p">)</span>
              <span class="c"># os.close (self.child_err)</span>


            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not run (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span> <span class="p">(</span><span class="n">command</span><span class="p">))</span>


        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;pty or process creation failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>

    <span class="c"># --------------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">__del__</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Need to free pty&#39;s on destruction, otherwise we might ran out of</span>
<span class="sd">        them (see cat /proc/sys/kernel/pty/max)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># kill the child, close all I/O channels</span>

        <span class="k">try</span> <span class="p">:</span>
            <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span> <span class="p">:</span>
            <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGKILL</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_in</span><span class="p">)</span>  
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_in</span><span class="p">)</span>    
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">)</span> 
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">close</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child_out</span><span class="p">)</span>   
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>

      <span class="c"># try : </span>
      <span class="c">#     os.close (self.parent_err) </span>
      <span class="c"># except OSError :</span>
      <span class="c">#     pass</span>
      <span class="c">#</span>
      <span class="c"># try : </span>
      <span class="c">#     os.close (self.child_err)   </span>
      <span class="c"># except OSError :</span>
      <span class="c">#     pass</span>


    <span class="c"># --------------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">alive</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
<div class="viewcode-block" id="PTYProcess.alive"><a class="viewcode-back" href="../../../developers/adaptorwriting.html#saga.utils.pty_process.PTYProcess.alive">[docs]</a>        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        alive() checks if the child gave an exit value -- if none, it is assumed</span>
<span class="sd">        to be still alive.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">try</span> <span class="p">:</span>
            <span class="n">pid</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;cannot check child status (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>


        <span class="c"># child is dead -- get last data into clog, if any</span>
        <span class="k">try</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">_force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="n">se</span><span class="o">.</span><span class="n">SagaException</span> <span class="p">:</span>
            <span class="k">pass</span>

        <span class="c"># avoid any further activity, inclusive waitpid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="bp">False</span>


    <span class="c"># --------------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">read</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">_CHUNKSIZE</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_force</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="p">:</span></div>
<div class="viewcode-block" id="PTYProcess.read"><a class="viewcode-back" href="../../../developers/adaptorwriting.html#saga.utils.pty_process.PTYProcess.read">[docs]</a>        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        read some data from the child.  By default, the method reads a full</span>
<span class="sd">        chunk, but other read sizes can be specified.  </span>
<span class="sd">        </span>
<span class="sd">        The method will return whatever data is has at timeout::</span>
<span class="sd">        </span>
<span class="sd">          timeout == 0 : return the content of the first successful read, with</span>
<span class="sd">                         whatever data up to &#39;size&#39; have been found.</span>
<span class="sd">          timeout &lt;  0 : return after first read attempt, even if no data have </span>
<span class="sd">                         been available.</span>

<span class="sd">        If no data are found, the method returns an empty string (not None).</span>

<span class="sd">        This method will not fill the cache, but will just read whatever data it</span>
<span class="sd">        needs (FIXME).</span>

<span class="sd">        Note: the returned lines do *not* get &#39;\\\\r&#39; stripped.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># start the timeout timer right now.  Note that even if timeout is</span>
        <span class="c"># short, and child.poll is slow, we will nevertheless attempt at least</span>
        <span class="c"># one read...</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_force</span> <span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not read - pty process died&quot;</span><span class="p">)</span>

        <span class="n">ret</span>     <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">sel_to</span>  <span class="o">=</span> <span class="n">timeout</span>

        <span class="c"># the select timeout cannot be negative -- 0 is non-blocking... </span>
        <span class="k">if</span>  <span class="n">sel_to</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> 
            <span class="n">sel_to</span> <span class="o">=</span> <span class="mi">0</span>


        <span class="c"># first, lets see if we still have data in the cache we can return</span>
        <span class="k">if</span> <span class="nb">len</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="p">:</span>

            <span class="c"># we don&#39;t even need all of the cache</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="nb">len</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">size</span><span class="p">:]</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="k">elif</span> <span class="n">size</span> <span class="o">==</span> <span class="nb">len</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="p">:</span>
                <span class="c"># doh!</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="k">else</span> <span class="p">:</span> <span class="c"># size &gt; len(self.cache)</span>
                <span class="c"># just use what we have, then go on to reading data</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="c"># read until we have enough data, or hit timeout ceiling...</span>
            <span class="k">while</span> <span class="bp">True</span> <span class="p">:</span>
            
                <span class="c"># idle wait &#39;til the next data chunk arrives, or &#39;til sel_to</span>
                <span class="n">rlist</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span> <span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">sel_to</span><span class="p">)</span>

                <span class="c"># got some data? </span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">rlist</span><span class="p">:</span>
                    <span class="c"># read whatever we still need</span>
                    <span class="n">buf</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clog</span> <span class="o">+=</span> <span class="n">buf</span>
                    <span class="n">ret</span>       <span class="o">+=</span> <span class="n">buf</span>

                    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">n&#39;</span><span class="p">)</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">if</span>  <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;read : [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s"> ... </span><span class="si">%s</span><span class="s">)&quot;</span> \
                                        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">buf</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">:]))</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;read : [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s">)&quot;</span> \
                                        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">buf</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> 
                    <span class="c"># only return if we have data</span>
                    <span class="k">if</span> <span class="nb">len</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span>

                <span class="k">elif</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="c"># return immediately</span>
                    <span class="k">return</span> <span class="n">ret</span>

                <span class="k">else</span> <span class="p">:</span> <span class="c"># timeout &gt; 0</span>
                    <span class="c"># return if timeout is reached, or if data size is reached</span>
                    <span class="k">if</span> <span class="nb">len</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span> <span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span>

                    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span> <span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;read from pty process failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>



    <span class="c"># --------------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">_readline</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span></div>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        read a line from the child.  This method will read data into the cache,</span>
<span class="sd">        and return whatever it finds up to (but not including) the first newline</span>
<span class="sd">        (\\\\n).  When timeout is met, the method will return None, and leave </span>
<span class="sd">        all data in the cache::</span>

<span class="sd">          timeout &lt;  0: reads are blocking until data arrive, and call will</span>
<span class="sd">                        only return when any complete line has been found (which</span>
<span class="sd">                        may be never)</span>

<span class="sd">          timeout == 0: reads do not block, and the call will only be successful</span>
<span class="sd">                        if a complete line is already in the cache, or is found</span>
<span class="sd">                        on the first read attempt.</span>

<span class="sd">          timeout &gt;  0: read calls block up to timeout, and reading is attempted</span>
<span class="sd">                        until timeout is reached, or a complete line is found,</span>
<span class="sd">                        whatever comes first.</span>

<span class="sd">        Note: the returned lines get &#39;\\\\r&#39; stripped.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># start the timeout timer right now.  Note that even if timeout is</span>
        <span class="c"># short, and child.poll is slow, we will nevertheless attempt at least</span>
        <span class="c"># one read...</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not read line - pty process died&quot;</span><span class="p">)</span>


        <span class="c"># check if we still have a full line in cache</span>
        <span class="c"># FIXME: what happens if cache == &#39;\n&#39; ?</span>
        <span class="k">if</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="p">:</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">index</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[:</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">rem</span>  <span class="c"># store the remainder back into the cache</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>


        <span class="k">try</span> <span class="p">:</span>
            <span class="c"># the cache is depleted, we need to read new data until we find</span>
            <span class="c"># a newline, or until timeout</span>
            <span class="k">while</span> <span class="bp">True</span> <span class="p">:</span>
            
                <span class="c"># do an idle wait &#39;til the next data chunk arrives</span>
                <span class="n">rlist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">rlist</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span> <span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">rlist</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span> <span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_out</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">timeout</span><span class="p">)</span>

                <span class="c"># got some data - read them into the cache</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">rlist</span><span class="p">:</span>
                    <span class="n">buf</span>         <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_CHUNKSIZE</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clog</span>  <span class="o">+=</span> <span class="n">buf</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">+=</span> <span class="n">buf</span>

                    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">n&#39;</span><span class="p">)</span>
                    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">if</span>  <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;read : [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s"> ... </span><span class="si">%s</span><span class="s">)&quot;</span> \
                                        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">buf</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">:]))</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;read : [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s">)&quot;</span> \
                                        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">buf</span><span class="p">))</span>

                <span class="c"># check if we *now* have a full line in cache</span>
                <span class="k">if</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="p">:</span>

                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">index</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[:</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">rem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">rem</span>  <span class="c"># store the remainder back into the cache</span>
                    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

                <span class="c"># if not, check if we hit timeout</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span> <span class="p">:</span>
                    <span class="c"># timeout, but nothing found -- leave cache alone and return</span>
                    <span class="k">return</span> <span class="bp">None</span>


        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;read from pty process failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>



    <span class="c"># ----------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">_findline</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This methods reads lines from the child process until a line matching</span>
<span class="sd">        any of the given patterns is found.  If that is found, all read lines</span>
<span class="sd">        (minus the matching one) are returned as a list of lines, the matching</span>
<span class="sd">        line itself is guaranteed to be the last line of the list.  This call</span>
<span class="sd">        never returns an empty list (the matching line is at least a linebreak).</span>

<span class="sd">        Note: the returned lines get &#39;\\\\r&#39; stripped.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not find line - pty process died&quot;</span><span class="p">)</span>


        <span class="k">try</span> <span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>             <span class="c"># startup timestamp</span>
            <span class="n">ret</span>   <span class="o">=</span> <span class="p">[]</span>                       <span class="c"># array of read lines</span>
            <span class="n">patts</span> <span class="o">=</span> <span class="p">[]</span>                       <span class="c"># compiled patterns</span>
            <span class="n">line</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readline</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="c"># first line to check</span>

            <span class="c"># pre-compile the given pattern, to speed up matching</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span> <span class="p">:</span>
                <span class="n">patts</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span> <span class="p">(</span><span class="n">pattern</span><span class="p">))</span>

            <span class="c"># we wait forever -- there are two ways out though: a line matches</span>
            <span class="c"># a pattern, or timeout passes</span>
            <span class="k">while</span> <span class="bp">True</span> <span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
                    <span class="k">break</span>

                <span class="c"># time.sleep (0.1)</span>

                <span class="c"># skip non-lines</span>
                <span class="k">if</span>  <span class="bp">None</span> <span class="o">==</span> <span class="n">line</span> <span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readline</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c"># check current line for any matching pattern</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">patts</span><span class="p">))</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">patts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">search</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="p">:</span>
                        <span class="c"># a pattern matched the current line: return a tuple of</span>
                        <span class="c"># pattern index, matching line, and previous lines.</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="n">ret</span><span class="p">)</span>

                <span class="c"># if a timeout is given, and actually passed, return a non-match</span>
                <span class="c"># and the set of lines found so far</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span> <span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

                <span class="c"># append current (non-matching) line to ret, and get new line </span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">))</span>
                <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readline</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;_readline from pty process failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>



    <span class="c"># ----------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">find</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
<div class="viewcode-block" id="PTYProcess.find"><a class="viewcode-back" href="../../../developers/adaptorwriting.html#saga.utils.pty_process.PTYProcess.find">[docs]</a>        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This methods reads bytes from the child process until a string matching</span>
<span class="sd">        any of the given patterns is found.  If that is found, all read data are</span>
<span class="sd">        returned as a string, up to (and including) the match.  Note that</span>
<span class="sd">        pattern can match an empty string, and the call then will return just</span>
<span class="sd">        that, an empty string.  If all patterns end with matching a newline,</span>
<span class="sd">        this method is effectively matching lines -- but note that &#39;$&#39; will also</span>
<span class="sd">        match the end of the (currently available) data stream.</span>

<span class="sd">        The call actually returns a tuple, containing the index of the matching</span>
<span class="sd">        pattern, and the string up to the match as described above.</span>

<span class="sd">        If no pattern is found before timeout, the call returns (None, None).</span>
<span class="sd">        Negative timeouts will block until a match is found</span>

<span class="sd">        Note that the pattern are interpreted with the re.M (multi-line) and</span>
<span class="sd">        re.S (dot matches all) regex flags.</span>

<span class="sd">        Performance: the call is doing repeated string regex searches over</span>
<span class="sd">        whatever data it finds.  On complex regexes, and large data, and small</span>
<span class="sd">        read buffers, this method can be expensive.  </span>

<span class="sd">        Note: the returned data get &#39;\\\\r&#39; stripped.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not find data - pty process died&quot;</span><span class="p">)</span>

        <span class="k">try</span> <span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>                       <span class="c"># startup timestamp</span>
            <span class="n">ret</span>   <span class="o">=</span> <span class="p">[]</span>                                 <span class="c"># array of read lines</span>
            <span class="n">patts</span> <span class="o">=</span> <span class="p">[]</span>                                 <span class="c"># compiled patterns</span>
            <span class="n">data</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>                         <span class="c"># initial data to check</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span> <span class="p">:</span> <span class="c"># empty cache?</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">_CHUNKSIZE</span><span class="p">,</span> <span class="n">_POLLDELAY</span><span class="p">)</span>

            <span class="c"># pre-compile the given pattern, to speed up matching</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span> <span class="p">:</span>
                <span class="n">patts</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">))</span>

            <span class="c"># we wait forever -- there are two ways out though: data matches</span>
            <span class="c"># a pattern, or timeout passes</span>
            <span class="k">while</span> <span class="bp">True</span> <span class="p">:</span>

              <span class="c"># time.sleep (0.1)</span>

                <span class="c"># skip non-lines</span>
                <span class="k">if</span>  <span class="bp">None</span> <span class="o">==</span> <span class="n">data</span> <span class="p">:</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">_CHUNKSIZE</span><span class="p">,</span> <span class="n">_POLLDELAY</span><span class="p">)</span>

                <span class="c"># check current data for any matching pattern</span>
              <span class="c"># print &quot;&gt;&gt;%s&lt;&lt;&quot; % data</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">patts</span><span class="p">))</span> <span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">patts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">search</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
                  <span class="c"># print &quot;==%s==&quot; % patterns[n]</span>
                    <span class="k">if</span> <span class="n">match</span> <span class="p">:</span>
                      <span class="c"># print &quot;~~match!~~ %s&quot; % data[match.start():match.end()]</span>
                      <span class="c"># print &quot;~~match!~~ %s&quot; % (len(data))</span>
                      <span class="c"># print &quot;~~match!~~ %s&quot; % (str(match.span()))</span>
                        <span class="c"># a pattern matched the current data: return a tuple of</span>
                        <span class="c"># pattern index and matching data.  The remainder of the</span>
                        <span class="c"># data is cached.</span>
                        <span class="n">ret</span>  <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> 
                      <span class="c"># print &quot;~~match!~~ %s&quot; % (ret)</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">))</span>

                <span class="c"># if a timeout is given, and actually passed, return a non-match</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="c"># no match yet, still time -- read more data</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="p">(</span><span class="n">_CHUNKSIZE</span><span class="p">,</span> <span class="n">_POLLDELAY</span><span class="p">)</span>


        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;find from pty process failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>



    <span class="c"># ----------------------------------------------------------------</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">write</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="p">:</span></div>
<div class="viewcode-block" id="PTYProcess.write"><a class="viewcode-back" href="../../../developers/adaptorwriting.html#saga.utils.pty_process.PTYProcess.write">[docs]</a>        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will repeatedly attempt to push the given data into the</span>
<span class="sd">        child&#39;s stdin pipe, until it succeeds to write all data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="p">()</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;Could not write data - pty not alive&quot;</span><span class="p">)</span>

        <span class="k">try</span> <span class="p">:</span>

            <span class="n">buf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">n&#39;</span><span class="p">)</span>
            <span class="n">buf</span> <span class="o">=</span>  <span class="n">buf</span><span class="o">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span>  <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;write: [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s"> ... </span><span class="si">%s</span><span class="s">)&quot;</span> \
                                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">buf</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">:]))</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">(</span><span class="s">&quot;write: [</span><span class="si">%5d</span><span class="s">] (</span><span class="si">%s</span><span class="s">)&quot;</span> \
                                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">buf</span><span class="p">))</span>

            <span class="c"># attempt to write forever -- until we succeeed</span>
            <span class="k">while</span> <span class="n">data</span> <span class="p">:</span>

                <span class="c"># check if the pty pipe is ready for data</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">wlist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span> <span class="p">([],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_in</span><span class="p">],</span> <span class="p">[],</span> <span class="n">_POLLDELAY</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">wlist</span> <span class="p">:</span>
                    
                    <span class="c"># write will report the number of written bytes</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">write</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

                    <span class="c"># otherwise, truncate by written data, and try again</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">size</span><span class="p">:]</span>

                    <span class="k">if</span> <span class="n">data</span> <span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="p">(</span><span class="s">&quot;write: [</span><span class="si">%5d</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>


        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">se</span><span class="o">.</span><span class="n">NoSuccess</span> <span class="p">(</span><span class="s">&quot;write to pty process failed (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>



<span class="c"># vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SAGA 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../saga.html" >saga</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, The SAGA Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>